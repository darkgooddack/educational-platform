import hashlib
from urllib.parse import urlencode
import secrets
import aiohttp
from fastapi.responses import RedirectResponse

from sqlalchemy.ext.asyncio import AsyncSession

from app.schemas import (
    OAuthUserSchema,
    TokenSchema,
    UserSchema,
    RegistrationSchema,
    BaseOAuthUserData,
    YandexUserData
)
from app.core.exceptions import (
    InvalidProviderError,
    OAuthInvalidGrantError,
    OAuthTokenError,
    OAuthConfigError,
    OAuthUserCreationError,
    OAuthUserDataError

)
from app.core.config import config
from app.core.clients import RedisClient
from app.core.security import HashingMixin, TokenMixin
from app.models import UserModel
from app.services import (
    BaseService,
    AuthService,
    UserService
)
from app.services.v1.oauth.providers import PROVIDER_HANDLERS
from ..auth import AuthDataManager


class OAuthService(HashingMixin, TokenMixin, BaseService):
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å OAuth –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞–º–∏"""

    def __init__(self, session: AsyncSession):
        super().__init__()
        self.providers = config.oauth_providers
        self._auth_service = AuthService(session)
        self._user_service = UserService(session)
        self._data_manager = AuthDataManager(session)

    async def oauthenticate(self, provider: str, code: str) -> TokenSchema:
        """
        –ü–æ–ª–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å OAuth –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏

        Args:
            provider: –ò–º—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ (vk/google/yandex)
            code: –ö–æ–¥, –ø–æ–ª—É—á–µ–Ω–Ω—ã–π –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞

        Returns:
            –¢–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞
        """
        # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        token_data = await self._get_provider_token(provider, code)

        self.logger.debug("token_data: %s", token_data)

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_data = await self._get_user_info(provider, token_data)

        self.logger.debug("user_data: %s", user_data)

        # –ò—â–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        created_user = await self._get_or_create_user(provider, user_data)

        # –ü–µ—Ä–µ–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        self.logger.debug("created_user: %s", created_user)

        return created_user

    async def _get_or_create_user(self, provider: str, user_data: BaseOAuthUserData) -> TokenSchema:
        """
        –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ OAuth –ø—Ä–æ–≤–∞–π–¥–µ—Ä.

        Args:
            provider: –ò–º—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ (vk/google/yandex)
            user_data: –î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞

        Returns:
            TokenSchema —Å access_token
        """

        # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ provider_id
        provider_field = f"{provider}_id"
        provider_id = str(user_data.id) if provider == "google" else int(user_data.id)

        # –ü–æ–ª—É—á–∞–µ–º email –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        user_email = (
            user_data.default_email if isinstance(user_data, YandexUserData)
            else user_data.email
        )

        if not user_email:
            self.logger.error("‚ùå Email –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            raise OAuthUserDataError(provider, "Email –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")

        self.logger.debug("üîç –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—É %s: %s", provider_field, provider_id)

        # –ü–æ–∏—Å–∫ –ø–æ provider_id
        user_schema = await self._user_service.get_by_field(provider_field, provider_id)

        if user_schema is None:
            self.logger.warning("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ provider_id, –ø—Ä–æ–±—É–µ–º –ø–æ email...")

            # –ü–æ–∏—Å–∫ –ø–æ email
            user_schema = await self._user_service.get_by_email(user_email)

            if user_schema is None:
                self.logger.warning("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ email, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...")

                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                oauth_user = OAuthUserSchema(
                    email=user_email,
                    first_name=user_data.first_name,
                    last_name=user_data.last_name,
                    avatar=str(user_data.avatar) if hasattr(user_data, 'avatar') else None,
                    password=secrets.token_hex(16), #! –ü–∞—Ä–æ–ª—å —Ç–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –ø—Ä–µ–¥–ª–∞–≥–∞—Ç—å –ø–æ–º–µ–Ω—è—Ç—å –∏–ª–∏ –ø—Ä–∏—Å–ª–∞—Ç—å –ø–æ –ø–æ—á—Ç–µ
                    **{provider_field: provider_id}
                )

                self.logger.debug("üìù –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å email: %s",user_email)
                oauth_user_dict = oauth_user.to_dict()
                registration_data = RegistrationSchema(**oauth_user_dict)

                try:
                    created_user = await self._user_service.create_oauth_user(registration_data)
                    self.logger.debug("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞—á–Ω–æ —Å–æ–∑–¥–∞–Ω —Å id: %s",created_user.id)
                except Exception as e:
                    self.logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: %s", e)
                    raise OAuthUserCreationError(provider, str(e)) from e

                # –°–æ–∑–¥–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                return await self._create_token(created_user)

        # –°–æ–∑–¥–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        return await self._auth_service.create_token(user_schema)

    async def _create_token(self, new_user: UserModel) -> TokenSchema:
        """
        –°–æ–∑–¥–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

        Attributes:
            user: –ú–æ–¥–µ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏

        Returns:
            TokenSchema: –¢–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞.

        TODO: –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–µ–ª–∞—Ç—å –ø–æ–ª—É—á—à–µ.
        """
        # –°–æ–∑–¥–∞–µ–º UserSchema –¥–ª—è —Ç–æ–∫–µ–Ω–∞
        user_schema = UserSchema(
            id=new_user.id,
            name=new_user.first_name,
            email=new_user.email,
            hashed_password=new_user.hashed_password
        )
        self.logger.debug("üîë –°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...")
        # –°–æ–∑–¥–∞–µ–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–∫–µ–Ω
        return await self._auth_service.create_token(user_schema)

    async def get_oauth_url(self, provider: str) -> RedirectResponse:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ URL –¥–ª—è OAuth2 –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏

        Args:
            provider: –ò–º—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ (vk/google/yandex)

        Returns:
            URL –¥–ª—è OAuth2 –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        """
        if provider not in self.providers:
            raise InvalidProviderError(provider)

        provider_config = self.providers[provider]
        self._validate_provider_config(provider, provider_config)
        auth_url = await self._build_auth_url(provider, provider_config)

        return RedirectResponse(auth_url)

    def _validate_provider_config(self, provider: str, provider_config: dict) -> None:
        """
        –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞.
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π.

        Args:
            provider_config (dict): –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞

        Raises:
            HTTPException: –ï—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
        """
        required_fields = ["client_id", "client_secret"]
        missing = [field for field in required_fields if field not in provider_config]
        if missing:
            raise OAuthConfigError(provider, missing)

    async def _build_auth_url(self, provider: str, _config: dict) -> str:
        """
        –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ URL –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.

        Args:
            provider (str): –ò–º—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
            provider_config (dict): –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞

        Returns:
            str: URL –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        """
        params = {
            "client_id": _config["client_id"],
            "redirect_uri": f"{config.app_url}/api/v1/oauth/{provider}/callback",
            "scope": _config.get("scope", ""),
            "response_type": "code",
        }
        if provider == "vk":
            code_verifier = secrets.token_urlsafe(64)
            code_challenge = hashlib.sha256(code_verifier.encode()).hexdigest()
            params.update({
                "state": secrets.token_urlsafe(32),
                "code_challenge": code_challenge,
                "code_challenge_method": "S256",
                "v": "5.131",
                "display": "page",
                "scope": "email phone",  # –î–æ–±–∞–≤–ª—è–µ–º –Ω—É–∂–Ω—ã–µ scope
                "prompt": "",  # –î–æ–±–∞–≤–ª—è–µ–º prompt
                "provider": "vkid",  # –£–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä
                "lang_id": "0",  # –†—É—Å—Å–∫–∏–π —è–∑—ã–∫
                "scheme": "light"  # –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞
            })
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º verifier —Ç–æ–ª—å–∫–æ –¥–ª—è VK
            redis = await RedisClient.get_instance()
            redis.set(f"oauth:verifier:{params['state']}", code_verifier, ex=300)

        return f"{_config['auth_url']}?{urlencode(params)}"

    # –ú–µ—Ç–æ–¥—ã —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞–º–∏
    async def _get_provider_token(self, provider: str, code: str) -> dict:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞.

        Args:
            provider (str): –ò–º—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
            code (str): –ö–æ–¥ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        Returns:
            dict: –î–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω–∞
        """
        provider_config = self.providers[provider]

        token_params = {
            "client_id": provider_config["client_id"],
            "client_secret": provider_config["client_secret"],
            "code": code,
            "redirect_uri": f"{config.app_url}/{config.oauth_url}/{provider}/callback",
            "grant_type": "authorization_code",
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                provider_config["token_url"],
                data=token_params
            ) as resp:
                token_data = await resp.json()
                if "error" in token_data and token_data["error"] == "invalid_grant":
                    raise OAuthInvalidGrantError(provider)
                elif "error" in token_data:
                    raise OAuthTokenError(provider, token_data["error"])
                return token_data

    async def _get_user_info(self, provider: str, token_data: dict) -> BaseOAuthUserData:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞.

        Args:
            provider (str): –ò–º—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
            token_data (dict): –î–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω–∞
        Returns:
            dict: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
        """
        provider_config = self.providers[provider]

        async with aiohttp.ClientSession() as session:
            headers = {
                "Authorization": f"Bearer {token_data['access_token']}"
            }
            async with session.get(
                provider_config["user_info_url"],
                headers=headers
            ) as resp:
                user_data = await resp.json()

        handler = PROVIDER_HANDLERS.get(provider)
        if not handler:
            raise InvalidProviderError(f"–ü—Ä–æ–≤–∞–π–¥–µ—Ä {provider} –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è")
        return await handler(user_data)
